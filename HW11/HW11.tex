\documentclass [10pt]{article}
\textheight	8.7in
\textwidth	6.5in
\topmargin	    0in
\oddsidemargin  0in
\evensidemargin 0in
\baselineskip 15pt

\usepackage{amssymb,amsmath,amstext}
\usepackage{amsfonts}
\usepackage{mathtools}

\newcommand\vartextvisiblespace[1][.7em]{%
  \makebox[#1]{%
    \kern.07em
    \vrule height.3ex
    \hrulefill
    \vrule height.3ex
    \kern.07em
  }% \langle -- don't forget this one!
}

\newcommand{\spacechar}{\vartextvisiblespace}% For ease-of-use

\newcommand{\reduces}{\preceq}% Just more intuitive

\begin{document}
\title{Theory of Computation Assignment no. 11}
\author{Goktug Saatcioglu}
\date{}
\maketitle

\begin{enumerate}
	\item[\textbf{(1)}]
	\begin{enumerate}
		\item[a.]If $A\reduces B$ then there exists a truth preserving reduction from $A$ to $B$. Furthermore, if $B\reduces C$ then there exists a truth preserving reduction from $B$ to $C$. Thus, we know that there is an algorithm $M_{1}$ (i.e. Turing machine) that takes an input word $x$ and outputs a word $y$ such that if $x\in A$ then $y\in B$ and if $x\notin A$ then $y\notin B$. We also know that there is an algorithm $M_{2}$ (i.e. Turing Machine) that takes an input word $y$ and outputs a word $z$ such that if $y\in B$ then $z\in C$ and if $y\notin B$ then $z\notin C$. Combining $M_{1}$ and $M_{2}$ together, we can create an algorithm $M_{3}$ (i.e. Turing machine) that takes an input $x$ and first simulates $M_{1}$ to get an output $y$. Then $M_{3}$ will simulate $M_{2}$ on $y$ to get $z$. Firstly, since $M_{1}$ and $M_{2}$ is computable we know that $M_{3}$ is computable. Secondly, we see that if $x\in A$ then $y\in B$ then $z\in C$ (or if $x\notin A$ then $y\notin B$ then $z\notin C$) which implies that $x\in A$ then $z\in C$ (or $x\notin A$ then $z\notin C$) which proves that $\reduces$ is transitive. Thus, we conclude if $A\reduces B$ and $B\reduces C$ then $A\reduces C$.
		\item[b.]If $A\reduces_{p}B$ then there exists a truth preserving polynomial time reduction from $A$ to $B$. Furthermore, if $B\reduces_{p}C$ then there exists a truth preserving polynomial time reduction from $B$ to $C$. Thus, we know that there is an algorithm $M_{1}$ (i.e. Turing machine) that takes an input word $x$ and outputs a word $y$ such that if $x\in A$ then $y\in B$ and if $x\notin A$ then $y\notin B$ in some time polynomial in the length of the input $x$ (where $\left|x\right|=n$). We also know that there is an algorithm $M_{2}$ (i.e. Turing Machine) that takes an input word $y$ and outputs a word $z$ such that if $y\in B$ then $z\in C$ and if $y\notin B$ then $z\notin C$ in some time polynomial in length of the input $y$ (where $\left|x\right|=o$). Combining $M_{1}$ and $M_{2}$ together, we can create an algorithm $M_{3}$ (i.e. Turing machine) that takes an input $x$ and first simulates $M_{1}$ to get an output $y$. Then $M_{3}$ will simulate $M_{2}$ on $y$ to get $z$. Firstly, since $M_{1}$ and $M_{2}$ is computable we know that $M_{3}$ is computable. Secondly, we see that if $x\in A$ then $y\in B$ then $z\in C$ (or if $x\notin A$ then $y\notin B$ then $z\notin C$) which implies that $x\in A$ then $z\in C$ (or $x\notin A$ then $z\notin C$). Thirdly, since $M_{1}$ runs in polynomial time in the length of the input $x$ (where $\left|x\right|=n$) and since $M_{2}$ runs in polynomial time in the length of input $y$ where $\left|y\right|=o$) we know that $M_{3}$ also runs in polynomial time in the length of the input $x$. All three points combined proves that $\reduces_{p}$ is transitive and we conclude if $A\reduces_{p}B$ and $B\reduces_{p}C$ then $A\reduces_{p}C$.
		\item[c.]We can use the same reduction as the one for all $L\in RE$, $L\reduces ACCEPT$. Let $M_{f}$ be a reduction algorithm from $L$ to $ACCEPT$ and $M$ be a Turing machine such that $L(M)=L$. We know that $M$ exists since we assume that $L\in RE$. Then, $M_{f}$, given an input $w$, creates the Turing machine $M$ described above and then outputs the descriptions of $M$ and $w$ (i.e. $(\langle M\rangle,\langle w\rangle)$). We see that $M_{f}$ is a truth-preserving reduction from $L$ to $ACCEPT$ since if a word $w\in L(M)$ then $\langle M, w\rangle\in ACCEPT$ and if $w\notin L(M)$ then $\langle M, w\rangle\notin ACCEPT$. Furthermore, $M_{f}$ is computable since we can encode both $M$ and $w$ according to the encoding scheme discussed in class. Finally, we know that the runtime of $M_{f}$ is polynomial in the length of $w$ (where $\left|w\right|=n$) since $M$ is given (i.e. a constant) meaning we can encode both $M$ and $w$ in polynomial time. Thus, we conclude that for all $L\in RE$, $L\reduces_{p} ACCEPT$.
		\item[d.]Let $A\in R$ and $B\subseteq \Sigma^{*}$ such that $B\notin\{\emptyset,\Sigma^{*}\}$. Then there exists a Turing machine $M$ that decides $A$ because we assume that $A\in R$ and there exists two words $w_{1},w_{2}\in\Sigma^{*}$ such that $w_{1}\in B$ and $w_{2}\notin B$ because we assume that $B\notin\{\emptyset,\Sigma^{*}\}$. To get a truth preserving reduction from $A$ to $B$ consider the following algorithm $M_{f}$ (i.e. Turing machine). $M_{f}$ given an input $w$ will simulate $M$ on $w$ where if $M$ accepts then $M_{f}$ outputs $w_{1}$ and if $M$ rejects then $M_{f}$ outputs $w_{2}$. Firstly, $M_{f}$ is computable since by assumption we know that $M$ is computable (because $A\in R$). Secondly, if $w\in A$ then $M$ will accept and $M_{f}$ outputs $w_{1}\in B$ and if $w\notin A$ then $M$ will reject and $M_{f}$ outputs $w_{2}\notin B$ which means that $M_{f}$ is a truth-preserving reduction from $A$ to $B$. Thus, we conclude that $A\reduces B$ for every two languages $A,B\in R$, as long as $B$ is not the empty language nor the language containing all words.
		\item[e.]Let $A\in P$ and $B\subseteq \Sigma^{*}$ such that $B\notin\{\emptyset,\Sigma^{*}\}$. Then there exists a Turing machine $M$ that computes $A$ in polynomial time in the length of some input $w$ (where $\left|w\right|=n$) because we assume that $A\in P$. Furthermore, we know that there exists two words $w_{1},w_{2}\in\Sigma^{*}$ such that $w_{1}\in B$ and $w_{2}\notin B$ because we assume that $B\notin\{\emptyset,\Sigma^{*}\}$. To get a truth preserving reduction from $A$ to $B$ consider the following algorithm $M_{f}$ (i.e. Turing machine). $M_{f}$ given an input $w$ will simulate $M$ on $w$ where if $M$ accepts then $M_{f}$ outputs $w_{1}$ and if $M$ rejects then $M_{f}$ outputs $w_{2}$. Firstly, $M_{f}$ is computable in polynomial time in the length of input $w$ since by assumption we know that $M$ is computable in polynomial time in the length of input $w$ (because $A\in P$). Secondly, if $w\in A$ then $M$ will accept and $M_{f}$ outputs $w_{1}\in B$ and if $w\notin A$ then $M$ will reject and $M_{f}$ outputs $w_{2}\notin B$ which means that $M_{f}$ is a truth-preserving polynomial time reduction from $A$ to $B$. Thus, we conclude that $A\reduces_{p} B$ for every two languages $A,B\in P$, as long as $B$ is not the empty language nor the language containing all words.
	\end{enumerate}
	\item[\textbf{(2)}]
	\begin{enumerate}
		\item[a.]We begin by defining a Turing machine $N$ such that $L(N)=\Sigma^{*}$. We know that such a machine exists and is easy to create since we just need to accept regardless of input. Then consider the following algorithm $M_{f}$ that takes as input descriptions of a Turing machine $\langle M^{\prime}\rangle$ and a word $\langle w^{\prime}\rangle$:
		\begin{align}
			&\text{$M_{f}(\langle M^{\prime}\rangle,\langle w^{\prime}\rangle)$:}\nonumber\\
			&\quad\text{$1$. Construct a TM $M$ that ignores its input $w$ and simulates $M^{\prime}$ on $\lambda$.}\nonumber\\
			&\quad\text{\quad\:$M$ accepts if $M$ halts on $\lambda$.}\nonumber\\
			&\quad\text{$2$. Construct a TM $N$ that always accepts its input (i.e. $L(N)=\Sigma^{*}$).}\nonumber\\
			&\quad\text{$3$. Output ($\langle N\rangle$, $\langle M\rangle$).}\nonumber
		\end{align}
		Now, if $M^{\prime}$ halts on $\lambda$ then the language of $M$ is given by $\Sigma^{*}$ since $M$ accepts all words $w$. In other words, if $M^{\prime}$ halts on $\lambda$ then $L(M)=\Sigma^{*}$ which then means that $L(N)\subseteq L(M)$. Conversely, if $M^{\prime}$ does not halt on $\lambda$ then $M$ runs (implicitly) infinitely for all words $w$ meaning $L(M)=\emptyset$ and $L(N)\not\subseteq L(M)$. Thus, $M_{f}$ is a truth-preserving reduction from $HALT_{\lambda}$ to $CONTAINED\_TM$ and we conclude $HALT_{\lambda}\reduces CONTAINED\_TM$.
		\item[b.]Again, we define the Turing machine $N$ but this time we change $L(N)$. Consider the algorithm $M_{f}$ that takes as input descriptions of a Turing machine $\langle M^{\prime}\rangle$ and a word $\langle w^{\prime}\rangle$ of length $n$ (i.e. $\left|w^{\prime}\right|=n$):
		\begin{align}
			&\text{$M_{f}(\langle M^{\prime}\rangle,\langle w^{\prime}\rangle)$:}\nonumber\\
			&\quad\text{$1$. Compute $n=\left|w^{\prime}\right|$.}\nonumber\\
			&\quad\text{\quad\:Construct a TM $M$ that ignores its input $w$ and simulates $M^{\prime}$ on $\lambda$ for $n$ steps.}\nonumber\\
			&\quad\text{\quad\:$M$ enters an infinite loop if $M^{\prime}$ halts at any point during the simulation,}\nonumber\\
			&\quad\text{\quad\:otherwise $M$ accepts.}\nonumber\\
			&\quad\text{$2$. Construct a TM $N$ that accepts inputs with length greater than or equal to $n$ (i.e. accept if $\left|w^{\prime}\right|\ge n$).}\nonumber\\
			&\quad\text{$3$. Output ($\langle N\rangle$, $\langle M\rangle$).}\nonumber
		\end{align}
		Similarly to a., if $M^{\prime}$ does not halt on $\lambda$ in $n$ steps then $L(N)\subseteq L(M)$ because $M$ halts on all $w$ with length greater than or equal to $n$. Conversely, if $M^{\prime}$ does halt on $\lambda$ in $n$ steps then it would enter an infinite loop for all $w$ meaning $L(M)=\emptyset$ and $L(N)\not\subseteq L(M)$. Thus, $M_{f}$ is a truth-preserving reduction from $(HALT_{\lambda})^{c}$ to $CONTAINED\_TM$ and we conclude $(HALT_{\lambda})^{c}\reduces CONTAINED\_TM$.
	\end{enumerate}
	\item[\textbf{(3)}]
	\begin{enumerate}

		\item[a.]Let $\Sigma$ be the alphabet of at least two letters such that it is the alphabet for an instance of $PCP$, say $P$. We know that the strings of $P$ are in the form $((s_{1},t_{1}),\dots,(s_{n},t_{n}))$ and we seek to create two context free grammars $G$ and $H$ which respectively generate the $s$ strings and $t$ strings along with the information about the indices of the strings used. For our grammars we use the alphabet $\Sigma$ along with $n$ words that are not in $\Sigma$ (so that we can avoid conflicts) to denote indices of strings. Let these $n$ words be in the form $l_{1},\dots,l_{n}$ and assume that they are not in $\Sigma$. Now, we need $G$ to create the $s$ strings in the form $s_{i}Gl_{i}$ so that we can generate a $s$ string along with its corresponding index (given by $l$). Thus, the CFG $G$ is given by$$G\rightarrow s_{1}Gl_{1}\:|\:\dots\:|\:s_{n}Gl_{n}\:|\:s_{1}n_{1}\:|\:\dots\:|\:s_{n}l_{n}.$$Similarly, for $H$ we need to create the $t$ strings in the form $t_{i}Hl_{i}$ so that we can generate a $t$ string along with its corresponding index (given by $l$). Thus, the CFG $H$ is given by$$H\rightarrow t_{1}Hl_{1}\:|\:\dots\:|\:t_{n}Hl_{n}\:|\:t_{1}n_{1}\:|\:\dots\:|\:t_{n}l_{n}.$$Now let $w$ be a word that describes $((s_{1},t_{1}),\dots,(s_{n},t_{n}))$. We notice that if $w$ is in $P$ (i.e. $w\in P$) then there also exists an intersection of the grammars $G$ and $H$ which is not empty (i.e. $G\cap H\ne\emptyset$). Conversely, if $w\notin P$ then $G\cap H=\emptyset$. Thus, given an instance of $PCP$, the algorithm that generates the grammars $G$ and $H$ as described above is a truth-preserving reduction from $PCP$ to $INTERSECT\_CFL$ and we conclude $PCP\reduces INTERSECT\_CFL$.
		\item[b.]We know that if $A\reduces B$ and $A\notin R$, then $B\notin R$ (which has been shown in class). Furthermore, from a. (above) we know that $PCP\reduces INTERSECT\_CFL$ which means that if $PCP\notin R$, then $INTERSECT\_CFL\notin R$. In fact, since we know that $PCP\notin R$ (as given by the question) and $PCP\reduces INTERSECT\_CFL$, we know that $INTERSECT\_CFL\notin R$.
	\end{enumerate}
	\item[\textbf{(4)}]
	\begin{enumerate}
		\item[a.]We need to give an algorithm that takes a graph $G$ and gives a new graph $G^{\prime}$ such that if $G\in3COL$ then $G^{\prime}\in4COL$ and if $G\notin 3COL$ then $G^{\prime}\notin 4COL$. Furthermore, this algorithm must run in polynomial time in length of the input $G$. Let $R$ be an algorithm that takes as input a graph $G=(V,E)$ with $V$ vertices and $E$ edges (where the edges are described as sets of $2$ vertices). Then $R$ creates a new graph $G^{\prime}=(V^{\prime},E^{\prime})$ where $V^{\prime}=V\cup \{w\}$ and $w$ is a new vertex (i.e. $w\notin V$) and $E^{\prime}=E\cup \{\{w,v\}\:|\:v\in V\}$. In other words, $R$ takes the graph $G$ and creates a new vertex $w$ which is then connected to all vertices in $G$ by edges which gives us the output graph $G^{\prime}$. Now, if $G$ has some three coloring then $G^{\prime}$ has the same exact three coloring by using the coloring of $G$ and then $G^{\prime}$ is four colorable by coloring the introduced vertex $w$ the fourth color. Conversely, if $G$ does not have a three coloring then $G^{\prime}$ will not have a four coloring since the addition of the introduced vertex $w$ can not lead to a four coloring. The algorithm $R$ runs takes linear time in length of the input $G$ since it creates a new vertex $w$ and then goes over all vertices of $G$ to create the new edges for $G^{\prime}$. Thus, $R$ (as described above) is a polynomial time truth-preserving reduction from $3COL$ to $4COL$ and we conclude $3COL\reduces_{p}4COL$.
		\item[b.]We know that $3COL\reduces_{p}4COL$ as this was shown above in a. and the algorithm that performs the reduction $R$ runs in linear time. Now, if $4COL\in P$ then there is exists some Turing machine $B$ that computes $4COL$ in polynomial time. To compute $3COL$ in polynomial time we can take an input graph $G=(V,E)$ with $V$ vertices and $E$ edges and first run it through our reduction algorithm $R$. This will give a resulting graph $G^{\prime}=(V^{\prime},E^{\prime})$ which is in $4COL$ if $G$ was in $3COL$ and which is not in $4COL$ if $G$ was not in $3COL$. We then use $B$ to check if $G^{\prime}$ is in $4COL$ where if $G^{\prime}\in4COL$ then we can conclude that $G\in3COL$ and if $G^{\prime}\notin4COL$ then we can conclude that $G\notin3COL$. We know that $R$ runs in linear time in input $G$, where $\left|G\right|=n$, and $B$ runs in polynomial time in input $G^{\prime}$ which means that our new algorithm runs in $n^{k}$ which is polynomial time. Thus, we conclude that if $4COL\in P$ then $3COL\in P$ since $3COL\reduces_{p}4COL$. (Note: It is also generally true that if $B\in P$ and $A\reduces_{p}B$ then $A\in P$.)
	\end{enumerate}
	\item[\textbf{(5)}]
	\begin{enumerate}
		\item[a.]We need to give an algorithm that takes an undirected graph $G$ and gives a new directed graph $G^{\prime}$ such that if $G\in HAM\_CYCLE$ then $G^{\prime}\in D\_HAM\_CYCLE$ and if $G\notin HAM\_CYCLE$ then $G^{\prime}\notin D\_HAM\_CYCLE$. Furthermore, this algorithm must run in polynomial time in length of the input $G$. Let $R$ be an algorithm that takes as input an undirected graph $G=(V,E)$ with $V$ vertices and $E$ edges (where the edges are described as sets of $2$ vertices). Then $R$ creates a new directed graph $G^{\prime}=(V^{\prime},E^{\prime})$ where $V^{\prime}=V$ and $E^{\prime}=\{\{u,v\}\:|\:\{u,v\}\in E\}$. In other words, $R$ takes the graph $G$ and creates a new directed graph $G^{\prime}$ where for each undirected edge between $u$ and $v$ in $G$ there are two directed edges $u\rightarrow v$ and $v\rightarrow u$ in $G^{\prime}$. Now, if the undirected graph $G$ has a Hamiltonian cycle $u_{1}\dots u_{n}$ then we know that $V$ has $n$ vertices where $\{u_{1},\dots,u_{n}\}=V$ and there exists at least an edge between each vertex in $V$ such that for each $1\le i< n\::\:\{u_{i},u_{i+1}\}\in E$ and $\{u_{n},u_{1}\}\in E$. This then implies that for each $1\le i< n\::\:\{u_{i},u_{i+1}\}\in E^{\prime}$ and $\{u_{n},u_{1}\}\in E^{\prime}$ (by construction of $R$) meaning $u_{1}\dots u_{n}$ is also an Hamiltonian cycle of the directed graph $G^{\prime}$. Conversely, if $G$ does not have an Hamiltonian cycle then $G^{\prime}$ cannot have an Hamiltonian cycle since $G^{\prime}$ is essentially $G$ with bi-directional edges. The algorithm $R$ takes polynomial time in length of the input $G$ since we traverse over all edges once and create two new edge pairs for $G^{\prime}$ for each edge we see. Thus, $R$ (as described above) is a polynomial time truth-preserving reduction from $HAM\_CYCLE$ to $D\_HAM\_CYCLE$ and we conclude $HAM\_CYCLE\reduces_{p}D\_HAM\_CYCLE$.
		\item[b.]We need to give an algorithm that takes a directed graph $G$ and gives a new undirected graph $G^{\prime}$ such that if $G\in D\_HAM\_CYCLE$ then $G^{\prime}\in HAM\_CYCLE$ and if $G\notin D\_HAM\_CYCLE$ then $G^{\prime}\notin HAM\_CYCLE$. Furthermore, this algorithm must run in polynomial time in length of the input $G$. Let $R$ be an algorithm that takes as input a directed graph $G=(V,E)$ with $V$ vertices and $E$ edges (where the edges are described as sets of $2$ vertices). Then $R$ creates a new undirected directed graph $G^{\prime}=(V^{\prime},E^{\prime})$ where $V^{\prime}=\{\{v_{in}\},\{v\},\{v_{out}\}\:|\:\{v\}\in V\}$ and $E^{\prime}=\{\{u_{out},v_{in}\},\{v_{in},v\},\{v,v_{out}\}\:|\:\{u,v\}\in E\}$. In other words, $R$ takes the graph the directed graph $G$ and creates a new undirected graph $G^{\prime}$ where for each directed edge between $u$ and $v$ in $G$ there is now an undirected edge that goes from the newly created $u_{out}$ vertex into $v_{in}$, $v_{in}$ goes into $v$ and $v$ goes to $v_{out}$. Now, if the directed graph $G$ has a Hamiltonian cycle $u_{1}\dots u_{n}$ then we know that $V$ has $n$ vertices where $\{u_{1},\dots,u_{n}\}=V$ and there exists at least an edge between each vertex in $V$ such that for each $1\le i< n\::\:\{u_{i},u_{i+1}\}\in E$ and $\{u_{n},u_{1}\}\in E$. This then implies that for each $1\le i< n\::\:\{(u_{i}),u_{i+1}\}\in E^{\prime}$ and $\{u_{n},u_{1}\}\in E^{\prime}$ (by construction of $R$) since we now have the Hamiltonian cycle $(u_{1})_{in}(u_{1})(u_{1})_{out}\dots(u_{n})_{in}(u_{n})(u_{n})_{out}$ in $G^{\prime}$. Conversely, if $G$ does not have an Hamiltonian cycle then $G^{\prime}$ cannot have an Hamiltonian cycle since $G^{\prime}$ is essentially $G$ with $3n$ vertices that has the same ``structure'' as $G$. The algorithm $R$ takes polynomial time in length of the input $G$ since we traverse over all vertices once to create the three new vertices and then traverse over all edges once to create the relevant edges in $G^{\prime}$ for each edge we see. Thus, $R$ (as described above) is a polynomial time truth-preserving reduction from $D\_HAM\_CYCLE$ to $HAM\_CYCLE$ and we conclude $D\_HAM\_CYCLE\reduces_{p}HAM\_CYCLE$.
	\end{enumerate}
\end{enumerate}


\end{document}